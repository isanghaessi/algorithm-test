{\rtf1\ansi
{\fonttbl\f0\fnil\fcharset0 HelveticaNeue;}
{\colortbl;}
{\*\listtable}
{\*\listoverridetable}
\f0\fs24 \cf0 \pard\tx0\tx500\tx1000\tx1500\tx2000\tx2500\tx3000\tx3500\tx4000\tx4500\tx5000\tx5500\tx6000\ql\fi0\li0
\uc0\u49707 \uc0\u51088  \uc0\u51665 \uc0\u54633  candidates\uc0\u47484  \uc0\u51312 \uc0\u54633 \uc0\u54616 \uc0\u50668  \uc0\u54633 \uc0\u51060  target\uc0\u51060  \uc0\u46104 \uc0\u45716  \uc0\u50896 \uc0\u49548 \uc0\u47484  \uc0\u45208 \uc0\u50676 \uc0\u54616 \uc0\u46972 . \uc0\u44033  \uc0\u50896 \uc0\u49548 \uc0\u45716  \uc0\u51473 \uc0\u48373 \uc0\u51004 \uc0\u47196  \uc0\u45208 \uc0\u50676  \uc0\u44032 \uc0\u45733 \uc0\u54616 \uc0\u45796 .\
\
Input: candidates = [2,3,6,7], target = 7\
Output: [[2,2,3],[7]]\
\
1.dfs\
class Solution:\
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\
        def dfs(cur, nex):\
            _sum = sum(cur)\
            if _sum > target:\
                return\
            elif _sum == target:\
                result.add(tuple(sorted(cur)))\
                return\
            for i, n in enumerate(nex):\
                _cur = cur[:]\
                _cur.append(n)\
                dfs(_cur, nex)\
        \
        result = set()\
        dfs([], candidates)\
        return [list(r) for r in result]\
\
class Solution:\
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\
        def dfs(csum, index, path):\
            if csum < 0:\
                return\
            if csum == 0:\
                result.append(path)\
                return\
            for i in range(index, len(candidates)):\
                dfs(csum - candidates[i], i, path + [candidates[i]])\
        \
        result = []\
        dfs(target, 0, [])\
        return result\
\
class Solution:\
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\
        result = []\
        \
        def dfs(chosen, nums):\
            _sum = sum(chosen)\
            if _sum > target:\
                \
                return\
            chosen.sort()\
            if _sum == target and chosen not in result:\
                result.append(chosen)\
            for n in nums:\
                dfs(chosen + [n], nums)\
                    \
        \
        dfs([], candidates)\
        \
        return result\
\
class Solution:\
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\
        result = []\
        \
        def dfs(chosen, index, nums):\
            _sum = sum(chosen)\
            if _sum > target:\
                \
                return\
            if _sum == target and chosen not in result:\
                result.append(chosen)\
            for i in range(index, len(nums)):\
                dfs(chosen + [nums[i]], i, nums)\
                    \
        \
        dfs([], 0, candidates)\
        \
        return result\
\
class Solution:\
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\
        def dfs(current):\
            current_sum = sum(current)\
            if current_sum > target:\
                \
                return\
            elif current_sum == target:\
                answer.add(tuple(sorted(current)))\
            else:\
                for candidate in candidates:\
                    dfs([*current, candidate])\
            \
        \
        answer = set()\
        dfs([])\
        return list(map(list, answer))\
\
class Solution:\
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\
        def dfs(left, current):\
            current_sum = sum(current)\
            if current_sum > target:\
                \
                return\
            elif current_sum == target:\
                answer.append(current)\
            else:\
                for i, candidate in enumerate(candidates[left:]):\
                    dfs(left + i, [*current, candidate])\
            \
        \
        answer = []\
        dfs(0, [])\
        return list(map(list, answer))}