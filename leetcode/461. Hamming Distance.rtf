{\rtf1\ansi
{\fonttbl\f0\fnil\fcharset0 HelveticaNeue;}
{\colortbl;}
{\*\listtable}
{\*\listoverridetable}
\f0\fs24 \cf0 \pard\tx0\tx500\tx1000\tx1500\tx2000\tx2500\tx3000\tx3500\tx4000\tx4500\tx5000\tx5500\tx6000\ql\fi0\li0
\uc0\u46160  \uc0\u51221 \uc0\u49688 \uc0\u47484  \uc0\u51077 \uc0\u47141 \uc0\u48155 \uc0\u50500  \uc0\u47751  \uc0\u48708 \uc0\u53944 \uc0\u44032  \uc0\u45796 \uc0\u47480 \uc0\u51648  \uc0\u44228 \uc0\u49328 \uc0\u54616 \uc0\u46972 .\
\
Input: x = 1, y = 4\
Output: 2\
Explanation:\
1   (0 0 0 1)\
4   (0 1 0 0)\
       \uc0\u8593    \uc0\u8593 \
The above arrows point to positions where the corresponding bits are different.]\
\
1.\uc0\u48708 \uc0\u53944  \uc0\u50672 \uc0\u49328  shift\
class Solution:\
    def hammingDistance(self, x: int, y: int) -> int:\
        result = 0\
        z = x ^ y\
        while z != 0:\
            if (z & 1):\
                result += 1\
            z >>= 1\
        return result\
\
class Solution:\
    def hammingDistance(self, x: int, y: int) -> int:\
        return bin(x ^ y).count('1')\
\
class Solution:\
    def hammingDistance(self, x: int, y: int) -> int:\
        \
        return bin(x ^ y).count('1')}