{\rtf1\ansi
{\fonttbl\f0\fnil\fcharset0 HelveticaNeue;}
{\colortbl;}
{\*\listtable}
{\*\listoverridetable}
\f0\fs24 \cf0 \pard\tx0\tx500\tx1000\tx1500\tx2000\tx2500\tx3000\tx3500\tx4000\tx4500\tx5000\tx5500\tx6000\ql\fi0\li0
\uc0\u50896 \uc0\u54805  \uc0\u53328 \uc0\u47484  \uc0\u46356 \uc0\u51088 \uc0\u51064 \uc0\u54616 \uc0\u46972 .\
\
\uc0\u8226 \	MyCircularQueue(k) Initializes the object with the size of the queue to be k.\
\uc0\u8226 \	int Front() Gets the front item from the queue. If the queue is empty, return -1.\
\uc0\u8226 \	int Rear() Gets the last item from the queue. If the queue is empty, return -1.\
\uc0\u8226 \	boolean enQueue(int value) Inserts an element into the circular queue. Return true if the operation is  successful.\
\uc0\u8226 \	boolean deQueue() Deletes an element from the circular queue. Return true if the operation is successful.\
\uc0\u8226 \	boolean isEmpty() Checks whether the circular queue is empty or not.\
\uc0\u8226 \	boolean isFull() Checks whether the circular queue is full or not.\
\
1.\
class MyCircularQueue:\
\
    def __init__(self, k: int):\
        self.q = [None] * k\
        self.maxLen = k\
        self.p1 = self.p2 = 0\
        \
        \
    def enQueue(self, value: int) -> bool:\
        if self.q[self.p2] is None:\
            self.q[self.p2] = value\
            self.p2 = (self.p2 + 1) % self.maxLen\
            return True\
        return False\
    \
    \
    def deQueue(self) -> bool:\
        if self.q[self.p1] is not None:\
            self.q[self.p1] = None\
            self.p1 = (self.p1 + 1) % self.maxLen\
            return True\
        return False\
            \
\
    def Front(self) -> int:\
        return -1 if self.q[self.p1] is None else self.q[self.p1]\
\
    \
    def Rear(self) -> int:\
        return -1 if self.q[self.p2 - 1] is None else self.q[self.p2 - 1]\
\
    \
    def isEmpty(self) -> bool:\
        return self.p1 == self.p2 and self.q[self.p1] is None\
\
    \
    def isFull(self) -> bool:\
        return self.p1 == self.p2 and self.q[self.p2] is not None\
        \
\
\
# Your MyCircularQueue object will be instantiated and called as such:\
# obj = MyCircularQueue(k)\
# param_1 = obj.enQueue(value)\
# param_2 = obj.deQueue()\
# param_3 = obj.Front()\
# param_4 = obj.Rear()\
# param_5 = obj.isEmpty()\
# param_6 = obj.isFull()\
\
class MyCircularQueue:\
\
    def __init__(self, k: int):\
        self.size = k + 1\
        self.front = self.rear = -1\
        self.q = [0] * self.size\
        \
        \
    def enQueue(self, value: int) -> bool:\
        if(self.isFull()):\
            return False\
        self.rear = (self.rear + 1) % self.size\
        self.q[self.rear] = value\
        return True\
    \
    \
    def deQueue(self) -> bool:\
        if(self.isEmpty()):\
            return False\
        self.front = (self.front + 1) % self.size\
        return True\
\
\
    def Front(self) -> int:\
        if self.isEmpty():\
            return -1\
        self.front = (self.front + 1) % self.size\
        temp = self.q[self.front]\
        self.front = (self.front - 1) % self.size\
        return temp\
\
    \
    def Rear(self) -> int:\
        if self.isEmpty():\
            return -1\
        return self.q[self.rear]\
\
    \
    def isEmpty(self) -> bool:\
        return self.front == self.rear\
\
    \
    def isFull(self) -> bool:\
        return (self.front + 1) % self.size  == (self.rear + 2) % self.size\
        \
\
\
# Your MyCircularQueue object will be instantiated and called as such:\
# obj = MyCircularQueue(k)\
# param_1 = obj.enQueue(value)\
# param_2 = obj.deQueue()\
# param_3 = obj.Front()\
# param_4 = obj.Rear()\
# param_5 = obj.isEmpty()\
# param_6 = obj.isFull()\
\
class MyCircularQueue:\
\
    def __init__(self, k: int):\
        self._size = k + 1\
        self._front = self._rear = -1\
        self._queue = [None] * self._size\
        \
        \
    def enQueue(self, value: int) -> bool:\
        if(self.isFull()):\
            return False\
        self._rear = (self._rear + 1) % self._size\
        self._queue[self._rear] = value\
        return True\
    \
    \
    def deQueue(self) -> bool:\
        if(self.isEmpty()):\
            return False\
        self._front = (self._front + 1) % self._size\
        result = self._queue[self._front]\
        return True\
\
\
    def Front(self) -> int:\
        if self.isEmpty():\
            return -1\
        return self._queue[(self._front + 1) % self._size]\
\
    \
    def Rear(self) -> int:\
        if self.isEmpty():\
            return -1\
        return self._queue[self._rear]\
\
    \
    def isEmpty(self) -> bool:\
        return self._front == self._rear\
\
    \
    def isFull(self) -> bool:\
        return (self._front + 1) % self._size  == (self._rear + 2) % self._size\
        \
\
\
# Your MyCircularQueue object will be instantiated and called as such:\
# obj = MyCircularQueue(k)\
# param_1 = obj.enQueue(value)\
# param_2 = obj.deQueue()\
# param_3 = obj._front()\
# param_4 = obj._rear()\
# param_5 = obj.isEmpty()\
# param_6 = obj.isFull()}