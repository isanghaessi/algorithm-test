{\rtf1\ansi
{\fonttbl\f0\fnil\fcharset0 HelveticaNeue;}
{\colortbl;}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0\levelnfc23\levelnfcn23{\*\levelmarker \{disc\}}{\leveltext \'01\'95}{\levelnumbers;}\fi-500\li0\lin0}
{\listlevel\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0\levelnfc23\levelnfcn23{\*\levelmarker \{circle\}}{\leveltext \'01\uc0\u9702 _;}{\levelnumbers;}\fi-500\li500\lin500}
{\listlevel\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0\levelnfc23\levelnfcn23{\*\levelmarker \{diamond\}}{\leveltext \'01\uc0\u9656 _;}{\levelnumbers;}\fi-500\li1000\lin1000}
{\listlevel\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0\levelnfc23\levelnfcn23{\*\levelmarker \{disc\}}{\leveltext \'01\'95}{\levelnumbers;}\fi-500\li1500\lin1500}
{\listlevel\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0\levelnfc23\levelnfcn23{\*\levelmarker \{circle\}}{\leveltext \'01\uc0\u9702 _;}{\levelnumbers;}\fi-500\li2000\lin2000}
{\listlevel\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0\levelnfc23\levelnfcn23{\*\levelmarker \{diamond\}}{\leveltext \'01\uc0\u9656 _;}{\levelnumbers;}\fi-500\li2500\lin2500}
{\listlevel\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0\levelnfc23\levelnfcn23{\*\levelmarker \{disc\}}{\leveltext \'01\'95}{\levelnumbers;}\fi-500\li3000\lin3000}
{\listlevel\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0\levelnfc23\levelnfcn23{\*\levelmarker \{circle\}}{\leveltext \'01\uc0\u9702 _;}{\levelnumbers;}\fi-500\li3500\lin3500}
{\listlevel\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0\levelnfc23\levelnfcn23{\*\levelmarker \{diamond\}}{\leveltext \'01\uc0\u9656 _;}{\levelnumbers;}\fi-500\li4000\lin4000}
{\listname ;}\listid1410852993}
}
{\*\listoverridetable{\listoverride\listid1410852993\listoverridecount0\ls1410852993}}
\f0\fs24 \cf0 \pard\tx0\tx500\tx1000\tx1500\tx2000\tx2500\tx3000\tx3500\tx4000\tx4500\tx5000\tx5500\tx6000\ql\fi0\li0
[from, to]\uc0\u47196  \uc0\u44396 \uc0\u49457 \uc0\u46108  \uc0\u54637 \uc0\u44277 \uc0\u44428  \uc0\u47785 \uc0\u47197 \uc0\u51012  \uc0\u51060 \uc0\u50857 \uc0\u54644  JFK\uc0\u50640 \uc0\u49436  \uc0\u52636 \uc0\u48156 \uc0\u54616 \uc0\u45716  \uc0\u50668 \uc0\u54665  \uc0\u51068 \uc0\u51221 \uc0\u51012  \uc0\u44396 \uc0\u49457 \uc0\u54616 \uc0\u46972 . \uc0\u50668 \uc0\u47084  \uc0\u51068 \uc0\u51221 \uc0\u51060  \uc0\u51080 \uc0\u45716  \uc0\u44221 \uc0\u50864  \uc0\u49324 \uc0\u51204  \uc0\u50612 \uc0\u55064 \uc0\u49692 \uc0\u51004 \uc0\u47196  \uc0\u48169 \uc0\u47928 \uc0\u54620 \uc0\u45796 .\
\
Input: tickets = [["MUC","LHR"],["JFK","MUC"],["SFO","SJC"],["LHR","SFO"]]\
Output: ["JFK","MUC","LHR","SFO","SJC"]\
\
1.dfs\
class Solution:\
    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\
        def dfs(cur, nex):\
            if len(result) > 0:\
                return\
            if len(nex) == 0:\
                path = []\
                for i in range(len(cur)):\
                    path.append(cur[i][1])\
                result.append(path)\
                return\
            for i, n in enumerate(nex):\
                if n[0] == cur[-1][1]:\
                    _cur = cur[:]\
                    _nex = nex[:]\
                    _cur.append(_nex.pop(i))\
                    dfs(_cur, _nex)\
            \
        result = []\
        tickets.sort(key = lambda t: (t[0], t[1]))\
        dfs([['JFK','JFK'], ], tickets)\
        return result[0]\
\
import collections\
\
class Solution:\
    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\
        def dfs(f):\
            while graph[f]:\
                dfs(graph[f].pop(0))\
            route.append(f)\
        \
        route = []\
        graph = collections.defaultdict(list)\
        for f, t in sorted(tickets):\
            graph[f].append(t)\
        dfs('JFK')\
        return route[::-1]\
\
\pard\tx0\tx500\tx1000\tx1500\tx2000\tx2500\tx3000\tx3500\tx4000\tx4500\tx5000\tx5500\tx6000\ql\fi-1000\li2000
\ls1410852993\ilvl2{\listtext    \uc0\u9656    }pop(0)\uc0\u51012  pop(0)\uc0\u51004 \uc0\u47196  \uc0\u51460 \uc0\u50668 \uc0\u48372 \uc0\u51088 .\
\li2500
\ls1410852993\ilvl3{\listtext    \'95   }\uc0\u44536 \uc0\u47000 \uc0\u54532  \uc0\u44396 \uc0\u49457 \uc0\u51012  \uc0\u50528 \uc0\u52488 \uc0\u50640  \uc0\u50669 \uc0\u49692 \uc0\u51004 \uc0\u47196  \uc0\u54616 \uc0\u47732  pop(0)\uc0\u51004 \uc0\u47196  \uc0\u44032 \uc0\u45733 \
\pard\tx0\tx500\tx1000\tx1500\tx2000\tx2500\tx3000\tx3500\tx4000\tx4500\tx5000\tx5500\tx6000\ql\fi0\li0
\
import collections\
\
class Solution:\
    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\
        def dfs(f):\
            while graph[f]:\
                dfs(graph[f].pop())\
            route.append(f)\
        \
        route = []\
        graph = collections.defaultdict(list)\
        for f, t in sorted(tickets, reverse = True):\
            graph[f].append(t)\
        dfs('JFK')\
        return route[::-1]\
\
2.\uc0\u49828 \uc0\u53469 \
import collections\
\
class Solution:\
    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\
        graph = collections.defaultdict(list)\
        for f, t in sorted(tickets):\
            graph[f].append(t)\
        route, stack = [], ['JFK']\
        while stack:\
            while graph[stack[-1]]:\
                stack.append(graph[stack[-1]].pop(0))\
            route.append(stack.pop())\
        return route[::-1]\
\
import collections\
\
class Solution:\
    result = []\
    \
    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\
        def dfs(path, _from, __dict):\
            if len(self.result) == 0:\
                if len(__dict[_from]) == 0:\
                    if len(path) == len(tickets) + 1:\
                        self.result = path[:]\
\
                    return\
                for _ in range(len(__dict[_from])):\
                    to = __dict[_from].popleft()\
                    path.append(to)\
                    dfs(path, to, __dict)\
                    __dict[_from].append(to)\
                    path.pop()\
        \
        \
        tickets.sort(key = lambda x: (x[0], x[1]))\
        _dict = collections.defaultdict(collections.deque)\
        for t in tickets:\
            _dict[t[0]].append(t[1])\
        dfs(['JFK'], 'JFK', _dict)\
            \
        return self.result\
\
\
import collections\
import copy\
\
class Solution:\
    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\
        def dfs(path, tickets_dict):\
            nonlocal answer\
            \
            if len(answer) > 0:\
                \
                return\
            if len(list(filter(lambda a: len(a) > 0, tickets_dict.values()))) < 1:\
                answer = path\
            current = path[-1]\
            for tdc in tickets_dict[current]:\
                pass_tickets_dict = copy.deepcopy(tickets_dict)\
                pass_tickets_dict[current].remove(tdc)\
                dfs([*path, tdc], pass_tickets_dict)\
        \
        tickets_dict = collections.defaultdict(list)\
        for fr, to in tickets:\
            tickets_dict[fr].append(to)\
        for fr in tickets_dict:\
            tickets_dict[fr].sort()\
        answer = []\
        dfs(['JFK'], tickets_dict)\
        \
        return answer\
\
\
\
\
\
}