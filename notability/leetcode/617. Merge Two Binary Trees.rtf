{\rtf1\ansi
{\fonttbl\f0\fnil\fcharset0 HelveticaNeue;}
{\colortbl;}
{\*\listtable}
{\*\listoverridetable}
\f0\fs24 \cf0 \pard\tx0\tx500\tx1000\tx1500\tx2000\tx2500\tx3000\tx3500\tx4000\tx4500\tx5000\tx5500\tx6000\ql\fi0\li0
\uc0\u46160  \uc0\u51060 \uc0\u51652  \uc0\u53944 \uc0\u47532 \uc0\u47484  \uc0\u48337 \uc0\u54633 \uc0\u54616 \uc0\u46972 . \uc0\u51473 \uc0\u48373 \uc0\u46104 \uc0\u45716  \uc0\u45432 \uc0\u46300 \uc0\u45716  \uc0\u44050 \uc0\u51012  \uc0\u54633 \uc0\u49328 \uc0\u54620 \uc0\u45796 .\
\
Input: root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]\
Output: [3,4,5,5,4,null,7]\
\
# Definition for a binary tree node.\
# class TreeNode:\
#     def __init__(self, val=0, left=None, right=None):\
#         self.val = val\
#         self.left = left\
#         self.right = right\
\
1.dfs\
class Solution:\
    def mergeTrees(self, root1: TreeNode, root2: TreeNode) -> TreeNode:\
        def dfs(node1, node2):\
            if node1 == None and node2 == None:\
                return None\
            if node1 == None:\
                node1 = TreeNode()\
            if node2 == None:\
                node2 = TreeNode()\
            node1.left = dfs(node1.left, node2.left)\
            node1.right = dfs(node1.right, node2.right)\
            val = node1.val + node2.val\
            node1.val = val\
            return node1\
        \
        root1 = dfs(root1, root2)\
        return root1\
\
class Solution:\
    def mergeTrees(self, root1: TreeNode, root2: TreeNode) -> TreeNode:\
        if root1 and root2:\
            node = TreeNode(root1.val + root2.val)\
            node.left = self.mergeTrees(root1.left, root2.left)\
            node.right = self.mergeTrees(root1.right, root2.right)\
            return node\
        else:\
            return root1 or root2\
\
# Definition for a binary tree node.\
# class TreeNode:\
#     def __init__(self, val=0, left=None, right=None):\
#         self.val = val\
#         self.left = left\
#         self.right = right\
class Solution:\
    def mergeTrees(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> Optional[TreeNode]:\
        def dfs(root1, root2):\
            if not root1 and not root2:\
                \
                return root1\
            if not root1:\
                root1 = TreeNode()\
            if not root2:\
                root2 = TreeNode()\
            root1.val += root2.val\
            if not root1.left and root2.left:\
                root1.left = TreeNode()\
            if not root1.right and root2.right:\
                root1.right = TreeNode()\
            root1.left = dfs(root1.left, root2.left)\
            root1.right = dfs(root1.right ,root2.right)\
            \
            return root1\
        \
        \
        return dfs(root1, root2)\
\
# Definition for a binary tree node.\
# class TreeNode:\
#     def __init__(self, val=0, left=None, right=None):\
#         self.val = val\
#         self.left = left\
#         self.right = right\
class Solution:\
    def mergeTrees(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> Optional[TreeNode]:\
        if root1 and root2:\
            node = TreeNode()\
            node.val = root1.val + root2.val\
            node.left = self.mergeTrees(root1.left, root2.left)\
            node.right = self.mergeTrees(root1.right, root2.right)\
            \
            return node\
        else:\
            \
            return root1 or root2\
\
\
}