{\rtf1\ansi
{\fonttbl\f0\fnil\fcharset0 HelveticaNeue;}
{\colortbl;}
{\*\listtable}
{\*\listoverridetable}
\f0\fs24 \cf0 \pard\tx0\tx500\tx1000\tx1500\tx2000\tx2500\tx3000\tx3500\tx4000\tx4500\tx5000\tx5500\tx6000\ql\fi0\li0
\uc0\u51060 \uc0\u51652  \uc0\u53944 \uc0\u47532 \uc0\u50640 \uc0\u49436  \uc0\u46160  \uc0\u45432 \uc0\u46300  \uc0\u44036  \uc0\u44032 \uc0\u51109  \uc0\u44596  \uc0\u44221 \uc0\u47196 \uc0\u51032  \uc0\u44600 \uc0\u51060 \uc0\u47484  \uc0\u52636 \uc0\u47141 \uc0\u54616 \uc0\u46972 .\
\
Input: root = [1,2,3,4,5]\
Output: 3\
\
# Definition for a binary tree node.\
# class TreeNode:\
#     def __init__(self, val=0, left=None, right=None):\
#         self.val = val\
#         self.left = left\
#         self.right = right\
\
1.dfs\
class Solution:\
    result = 0\
    \
    def diameterOfBinaryTree(self, root: TreeNode) -> int:\
        def checkDepth(node, depth):\
            if node == None:\
                return depth - 1\
            return max(checkDepth(node.left, depth + 1), checkDepth(node.right, depth + 1))\
        \
        def check(node):\
            if node == None:\
                return\
            left = checkDepth(node.left, 1)\
            right = checkDepth(node.right, 1)\
            if self.result < left + right:\
                self.result = left + right\
            check(node.left)\
            check(node.right)\
            \
        check(root)\
        return self.result\
\
class Solution:\
    longest = 0\
    def diameterOfBinaryTree(self, root: TreeNode) -> int:\
        def dfs(node):\
            if not node:\
                return -1\
            left = dfs(node.left)\
            right = dfs(node.right)\
            self.longest = max(self.longest, left + right + 2)\
            return max(left, right) + 1\
        dfs(root)\
        return self.longest\
\
class Solution:\
    result = 0\
    \
    def diameterOfBinaryTree(self, root: TreeNode) -> int:\
        def preOrder(node, length):\
            if node == None:\
                \
                return length\
            left_length = preOrder(node.left, length)\
            right_length = preOrder(node.right, length)\
            self.result = max(self.result, left_length + right_length)\
            \
            return max(left_length , right_length) + 1\
\
\
        preOrder(root, 0)\
        \
        return self.result\
\
# Definition for a binary tree node.\
# class TreeNode:\
#     def __init__(self, val=0, left=None, right=None):\
#         self.val = val\
#         self.left = left\
#         self.right = right\
class Solution:\
    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:\
        def dfs(node, count):\
            nonlocal answer\
            \
            if node == None:\
                \
                return count\
            \
            left = dfs(node.left, count + 1)\
            right = dfs(node.right, count + 1)\
            answer = max(answer, left + right - count * 2 - 2)\
            \
            return max(left, right)\
\
            \
        if not root:\
            \
            return 0\
        answer = 0\
        left = dfs(root.left, 0)\
        right = dfs(root.right, 0)\
        answer = max(answer, left + right)\
        \
        return answer\
\
# Definition for a binary tree node.\
# class TreeNode:\
#     def __init__(self, val=0, left=None, right=None):\
#         self.val = val\
#         self.left = left\
#         self.right = right\
class Solution:\
    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:\
        def dfs(node):\
            nonlocal answer\
            \
            if node == None:\
                \
                return -1\
            \
            left = dfs(node.left)\
            right = dfs(node.right)\
            answer = max(answer, left + right + 2)\
            \
            return max(left, right) + 1\
\
            \
        if not root:\
            \
            return 0\
        answer = 0\
        dfs(root)\
        \
        return answer\
\
\
\
}