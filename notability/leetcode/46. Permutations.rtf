{\rtf1\ansi
{\fonttbl\f0\fnil\fcharset0 HelveticaNeue;}
{\colortbl;}
{\*\listtable}
{\*\listoverridetable}
\f0\fs24 \cf0 \pard\tx0\tx500\tx1000\tx1500\tx2000\tx2500\tx3000\tx3500\tx4000\tx4500\tx5000\tx5500\tx6000\ql\fi0\li0
\uc0\u49436 \uc0\u47196  \uc0\u45796 \uc0\u47480  \uc0\u51221 \uc0\u49688 \uc0\u47484  \uc0\u51077 \uc0\u47141 \uc0\u48155 \uc0\u50500  \uc0\u44032 \uc0\u45733 \uc0\u54620  \uc0\u47784 \uc0\u46304  \uc0\u49692 \uc0\u50676 \uc0\u51012  \uc0\u47532 \uc0\u53556 \uc0\u54616 \uc0\u46972 .\
\
Input: nums = [1,2,3]\
Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\
\
1.dfs\
from itertools import permutations\
\
class Solution:\
    def permute(self, nums: List[int]) -> List[List[int]]:    \
        def dfs(elements):\
            if len(elements) == 0:\
                results.append(prev_elements[:])\
            for e in elements:\
                next_elements = elements[:]\
                next_elements.remove(e)\
                prev_elements.append(e)\
                dfs(next_elements)\
                prev_elements.pop()\
                \
        results = []\
        prev_elements = []\
        dfs(nums)\
        return results\
\
class Solution:\
    def permute(self, nums: List[int]) -> List[List[int]]:\
        def dfs(cur, nex):\
            if len(nex) == 0:\
                result.append(cur)\
                return\
            for i, n in enumerate(nex):\
                _cur = cur[:]\
                _nex = nex[:]\
                _cur.append(_nex.pop(i))\
                dfs(_cur, _nex)\
        \
        result = []\
        dfs([], nums)\
        return result\
\
2.itertools.permutaionts \uc0\u47784 \uc0\u46280 \
from itertools import permutations\
\
class Solution:\
    def permute(self, nums: List[int]) -> List[List[int]]:\
        return [list(p) for p in list(permutations(nums, len(nums)))]\
\
class Solution:\
    def permute(self, nums: List[int]) -> List[List[int]]:\
        result = []\
        \
        def dfs(per, _nums):\
            if len(_nums) == 0:\
                result.append(per)\
                \
                return\
            for _n in _nums:\
                dfs(per + [_n], [__n for __n in _nums if __n != _n])\
        \
                    \
        dfs([], nums)\
        return result\
}